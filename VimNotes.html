<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Vim Notes</title>
    <meta name="generator" content="emacs-wiki.el" />
    <meta http-equiv="Content-Type"
          content="text/html; charset=utf-8" />
    <link rel="made" href="mailto:cyberpsyche[AT]gmail.com" />
    <link rel="home" href="WelcomePage.html" />
    <link rel="index" href="WikiIndex.html" />
    <link rel="stylesheet" type="text/css" href="main.css"><script type="text/javascript">
function showToolTip(machaine) {
  if (machaine != "")   {
    document.getElementById('tooltip').innerHTML     = machaine;
    document.getElementById('tooltipbox').style.visibility = 'visible';
  }
}
function hide() {
  document.getElementById('tooltip').innerHTML     = '';
  document.getElementById('tooltipbox').style.visibility = 'hidden';
}
</script>
<div class="menu">
<div class="menuitem">
  <a href="WelcomePage.html">Wiki</a>
</div>

<div class="menuitem">
  <a href="">work</a>
</div>

</div><!-- menu ends here -->
<div id="tooltipbox">
<div id="tooltip"></div>
</div>
  </head>
  <body>
    <h1 id="top">Vim Notes</h1>

    <!-- Page published by Emacs Wiki begins here -->
<h3>语法高亮</h3>

<p>
编辑~/.vimrc文件，写入syntax on

</p>

<h3>移动光标</h3>

<p>
上:k nk:向上移动n行 9999k或gg可以移到第一行 G移到最后一行

</p>

<p>
下:j nj:向下移动n行

</p>

<p>
左:h nh:向左移动n列

</p>

<p>
右:l nl:向右移动n列

</p>

<p>
w：光标以单词向前移动 nw：光标向前移动n个单词 光标到单词的第一个字母上

</p>

<p>
b：与w相反

</p>

<p>
e: 光标以单词向前移动 ne：光标向前移动n个单词 光标到单词的最后一个字母上

</p>

<p>
ge:与e相反

</p>

<p>
$:移动光标到行尾 n$:移动到第n行的行尾

</p>

<p>
0（Num）：移动光标到行首

</p>

<p>
^:移动光标到行首第一个非空字符上去

</p>

<p>
f< a >:移动光标到当前行的字符a上，nf< a >移动光标到当前行的第n个a字符上

</p>

<p>
F:相反

</p>

<p>
%:移动到与制匹配的括号上去（），{}，[]，<>等。

</p>

<p>
nG:移动到第n行上 G:到最后一行

</p>

<p>
CTRL＋G 得到当前光标在文件中的位置

</p>

<p>
向前翻页：CTRL+F

</p>

<p>
向下移动半屏：CTRL＋G

</p>

<p>
向后翻页：CTRL+B

</p>

<h3>快捷命令</h3>

<p>
%（跳转到与之匹配的括号处）

</p>

<p>
.（重复上次的修改命令）

</p>

<p>
`.（跳转到最近修改过的位置）

</p>

<p>
ZQ（无条件退出）

</p>

<p>
ZZ（存盘退出）

</p>

<p>
ga（显示光标下的字符在当前使用的 encoding 下的内码）

</p>

<p>
guw（光标下的单词变为小写）

</p>

<p>
gUw（光标下的单词变为大写）

</p>

<p>
:TOhtml（根据 Vim 的语法加亮的方式生成 HTML 代码；在图形界面中也可以使用菜单“Syntax－Convert to HTML”达到同样效果）

</p>

<h3>多文档编辑</h3>

<p>
vim -o file1 file2 file3 ...用分割屏幕窗口的方式同时打开多个文件。

</p>

<p>
使用按两次 ctrl+w 的方式或按一次 ctrl+w 再按上下键的方式在窗口间切换。

</p>

<h3>文本内跳转操作</h3>

<p>
ta - 跳到下一个a之前；

</p>

<p>
fa - 跳到下一个a；

</p>

<p>
dta - 删到下一个a之前；

</p>

<p>
dfa - 删到下一个a；

</p>

<p>
d$ - 删到行尾；

</p>

<p>
d^ - 删到行首第一个字符；

</p>

<p>
30% - 跳到文件30%处。

</p>

<p>
:tag 关键字（跳转到与“关键字”匹配的标记处）

</p>

<p>
:tselect [关键字]（显示与“关键字”匹配的标记列表，输入数字跳转到指定的标记）

</p>

<p>
:tjump [关键字]（类似于“:tselect”，但当匹配项只有一个时直接跳转至标记处而不再显示列表）

</p>

<p>
:tn（跳转到下一个匹配的标记处）

</p>

<p>
:tp（跳转到上一个匹配的标记处）

</p>

<p>
Ctrl-]（跳转到与光标下的关键字匹配的标记处；除“关键字”直接从光标位置自动获得外，功能与“:tags”相同）

</p>

<p>
g]（与“Ctrl-]”功能类似，但使用的命令是“:tselect”）

</p>

<p>
g Ctrl-]（与“Ctrl-]”功能类似，但使用的命令是“:tjump”）

</p>

<p>
Ctrl-T（跳转回上次使用以上命令跳转前的位置）

</p>

<h3>文件间跳转操作</h3>

<p>
将光标移动到文本中某一“文件名”下，可使用 gf 跳转到该文件。用 ctrl+o 可回到原文件。

</p>

<h3>自动补全</h3>

<p>
按 ctrl+p 进行terms的自动补全，如各种函数名。

</p>

<h3>搜索</h3>

<p>
将光标移动某一单词下，按 "\*" 向下搜索与所在单词完整匹配的词，按 "#" 向上搜索与所在单词完整匹配的词，"g*"向下搜索与所在单词部分匹配的词，

</p>

<p>
注：该功能非常有用！

</p>

<h3>Block编辑</h3>

<p>
按 v 进入visual编辑模式，可以按块编辑。

</p>

<p>
ctrl+v 进入加强式的块编辑，可编辑纵向的n列。

</p>

<h3>16/8进制查看</h3>

<p>
:%!xxd       16进制

</p>

<p>
:%!xxd -c 12  将当前文本转换为16进制格式,并每行显示12个字节

</p>

<p>
:%!od  8进制

</p>

<p>
:%!xxd -r    回到文本方式

</p>

<h3>打印</h3>

<p>
:[range]hardcopy[!] > {filename}

</p>

<p>
! 用于忽略对话框

</p>

<h3>输入特殊字符</h3>

<p>
:dig 或 :digraph

</p>

<p>
查看特殊字符的十进制数，用Ctrl-v NUM输入。

</p>

<h3>Vim Tips</h3>

<pre class="example">__BEGIN__
------------------------------------------------------------------------------
&quot; new items marked *N* , corrected items marked *C*
&quot; searching
/joe/e                      : cursor set to End of match
/joe/e+1                    : cursor set to End of match plus 1
/joe/s-2                    : cursor set to Start of match minus 2
/joe/+3                     : find joe move cursor 3 lines down
/^joe.*fred.*bill/          : find joe AND fred AND Bill (Joe at start of line)
/^[A-J]/                    : search for lines beginning with one or more A-J
/begin\_.*end               : search over possible multiple lines
/fred\_s*joe/               : any whitespace including newline *C*
/fred\|joe                  : Search for FRED OR JOE
/.*fred\&amp;.*joe              : Search for FRED AND JOE in any ORDER!
/\&lt;fred\&gt;/                  : search for fred but not alfred or frederick *C*
/\&lt;\d\d\d\d\&gt;               : Search for exactly 4 digit numbers
/\D\d\d\d\d\D               : Search for exactly 4 digit numbers
/\&lt;\d\{4}\&gt;                 : same thing
/\([^0-9]\|^\)%.*%          : Search for absence of a digit or beginning of line
&quot; finding empty lines
/^\n\{3}                    : find 3 empty lines
/^str.*\nstr                : find 2 successive lines starting with str
/\(^str.*\n\)\{2}           : find 2 successive lines starting with str
&quot; using rexexp memory in a search
/\(fred\).*\(joe\).*\2.*\1
&quot; Repeating the Regexp (rather than what the Regexp finds)
/^\([^,]*,\)\{8}
&quot; visual searching
:vmap // y/&lt;C-R&gt;&quot;&lt;CR&gt;       : search for visually highlighted text
:vmap &lt;silent&gt; //    y/&lt;C-R&gt;=escape(@&quot;, '\\/.*$^~[]')&lt;CR&gt;&lt;CR&gt; : with spec chars
&quot; \zs and \ze regex delimiters :h /\zs
/&lt;\zs[^&gt;]*\ze&gt;              : search for tag contents, ignoring chevrons
&quot; zero-width :h /\@=
/&lt;\@&lt;=[^&gt;]*&gt;\@=             : search for tag contents, ignoring chevrons
/&lt;\@&lt;=\_[^&gt;]*&gt;\@=           : search for tags across possible multiple lines
&quot; searching over multiple lines \_ means including newline
/&lt;!--\_p\{-}--&gt;                   : search for multiple line comments
/fred\_s*joe/                     : any whitespace including newline *C*
/bugs\(\_.\)*bunny                : bugs followed by bunny anywhere in file
:h \_                             : help
&quot; search for declaration of subroutine/function under cursor
:nmap gx yiw/^\(sub\&lt;bar&gt;function\)\s\+&lt;C-R&gt;&quot;&lt;CR&gt;
&quot; multiple file search
:bufdo /searchstr/                : use :rewind to recommence search
&quot; multiple file search better but cheating
:bufdo %s/searchstr/&amp;/gic   : say n and then a to stop
&quot; How to search for a URL without backslashing
?http://www.vim.org/        : (first) search BACKWARDS!!! clever huh!
&quot; Specify what you are NOT searching for (vowels)
/\c\v([^aeiou]&amp;\a){4}       : search for 4 consecutive consonants
/\%&gt;20l\%&lt;30lgoat           : Search for goat between lines 20 and 30 *N*
/^.\{-}home.\{-}\zshome/e   : match only the 2nd occurence in a line of &quot;home&quot; *N*
:%s/home.\{-}\zshome/alone  : Substitute only the occurrence of home in any line *N*
&quot; find str but not on lines containing tongue
^\(.*tongue.*\)\@!.*nose.*$
\v^((tongue)@!.)*nose((tongue)@!.)*$
.*nose.*\&amp;^\%(\%(tongue\)\@!.\)*$ 
:v/tongue/s/nose/&amp;/gic
&quot;----------------------------------------
&quot;substitution
:%s/fred/joe/igc            : general substitute command
:%s//joe/igc                : Substitute what you last searched for *N*
:%s/~/sue/igc               : Substitute your last replacement string *N*
:%s/\r//g                   : Delete DOS returns ^M
&quot; Is your Text File jumbled onto one line? use following
:%s/\r/\r/g                 : Turn DOS returns ^M into real returns
:%s=  *$==                  : delete end of line blanks
:%s= \+$==                  : Same thing
:%s#\s*\r\?$##              : Clean both trailing spaces AND DOS returns
:%s#\s*\r*$##               : same thing
&quot; deleting empty lines
:%s/^\n\{3}//               : delete blocks of 3 empty lines
:%s/^\n\+/\r/               : compressing empty lines
:%s#&lt;[^&gt;]\+&gt;##g             : delete html tags, leave text (non-greedy)
:%s#&lt;\_.\{-1,}&gt;##g          : delete html tags possibly multi-line (non-greedy)
:%s#.*\(\d\+hours\).*#\1#   : Delete all but memorised string (\1) *N*
&quot; VIM Power Substitute
:'a,'bg/fred/s/dick/joe/igc : VERY USEFUL
&quot; duplicating columns
:%s= [^ ]\+$=&amp;&amp;=            : duplicate end column
:%s= \f\+$=&amp;&amp;=              : same thing
:%s= \S\+$=&amp;&amp;               : usually the same
&quot; memory
%s#.*\(tbl_\w\+\).*#\1#     : produce a list of all strings tbl_*   *N*
:s/\(.*\):\(.*\)/\2 : \1/   : reverse fields separated by :
:%s/^\(.*\)\n\1$/\1/        : delete duplicate lines
&quot; non-greedy matching \{-}
:%s/^.\{-}pdf/new.pdf/      : delete to 1st pdf only
&quot; use of optional atom \?
:%s#\&lt;[zy]\?tbl_[a-z_]\+\&gt;#\L&amp;#gc : lowercase with optional leading characters
&quot; over possibly many lines
:%s/&lt;!--\_.\{-}--&gt;//        : delete possibly multi-line comments
:help /\{-}                 : help non-greedy
&quot; substitute using a register
:s/fred/&lt;c-r&gt;a/g            : sub &quot;fred&quot; with contents of register &quot;a&quot;
:s/fred/&lt;c-r&gt;asome_text&lt;c-r&gt;s/g  
:s/fred/\=@a/g              : better alternative as register not displayed
&quot; multiple commands on one line
:%s/\f\+\.gif\&gt;/\r&amp;\r/g | v/\.gif$/d | %s/gif/jpg/
:%s/a/but/gie|:update|:next : then use @: to repeat
&quot; ORing
:%s/goat\|cow/sheep/gc      : ORing (must break pipe)
:%s/\v(.*\n){5}/&amp;\r         : insert a blank line every 5 lines *N*
&quot; Calling a VIM function
:s/__date__/\=strftime(&quot;%c&quot;)/ : insert datestring
&quot; Working with Columns sub any str1 in col3
:%s:\(\(\w\+\s\+\)\{2}\)str1:\1str2:
&quot; Swapping first &amp; last column (4 columns)
:%s:\(\w\+\)\(.*\s\+\)\(\w\+\)$:\3\2\1:
&quot; format a mysql query 
:%s#\&lt;from\&gt;\|\&lt;where\&gt;\|\&lt;left join\&gt;\|\&lt;\inner join\&gt;#\r&amp;#g
&quot; filter all form elements into paste register
:redir @*|sil exec 'g#&lt;\(input\|select\|textarea\|/\=form\)\&gt;#p'|redir END
:nmap ,z :redir @*&lt;Bar&gt;sil exec 'g@&lt;\(input\&lt;Bar&gt;select\&lt;Bar&gt;textarea\&lt;Bar&gt;/\=form\)\&gt;@p'&lt;Bar&gt;redir END&lt;CR&gt;
&quot; substitute string in column 30 *N*
:%s/^\(.\{30\}\)xx/\1yy/
&quot; decrement numbers by 3
:%s/\d\+/\=(submatch(0)-3)/
&quot; increment numbers by 6 on certain lines only
:g/loc\|function/s/\d/\=submatch(0)+6/
&quot; better
:%s#txtdev\zs\d#\=submatch(0)+1#g
:h /\zs
&quot; increment only numbers gg\d\d  by 6 (another way)
:%s/\(gg\)\@&lt;=\d\+/\=submatch(0)+6/
:h zero-width
&quot; rename a string with an incrementing number
:let i=10 | 'a,'bg/Abc/s/yy/\=i/ |let i=i+1 # convert yy to 10,11,12 etc
&quot; as above but more precise
:let i=10 | 'a,'bg/Abc/s/xx\zsyy\ze/\=i/ |let i=i+1 # convert xxyy to xx11,xx12,xx13
&quot; find replacement text, put in memory, then use \zs to simplify substitute
:%s/&quot;\([^.]\+\).*\zsxx/\1/
&quot; Pull word under cursor into LHS of a substitute
:nmap &lt;leader&gt;z :%s#\&lt;&lt;c-r&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;cr&gt;\&gt;#
&quot; Pull Visually Highlighted text into LHS of a substitute
:vmap &lt;leader&gt;z :&lt;C-U&gt;%s/\&lt;&lt;c-r&gt;*\&gt;/
&quot; substitute singular or plural
:'a,'bs/bucket\(s\)*/bowl\1/gic   *N*
----------------------------------------
&quot; all following performing similar task, substitute within substitution
&quot; Multiple single character substitution in a portion of line only
:%s,\(all/.*\)\@&lt;=/,_,g     : replace all / with _ AFTER &quot;all/&quot;
&quot; Same thing
:s#all/\zs.*#\=substitute(submatch(0), '/', '_', 'g')#
&quot; Substitute by splitting line, then re-joining
:s#all/#&amp;^M#|s#/#_#g|-j!
&quot; Substitute inside substitute
:%s/.*/\='cp '.submatch(0).' all/'.substitute(submatch(0),'/','_','g')/
----------------------------------------
&quot; global command display 
:g/gladiolli/#              : display with line numbers (YOU WANT THIS!)
:g/fred.*joe.*dick/         : display all lines fred,joe &amp; dick
:g/\&lt;fred\&gt;/                : display all lines fred but not freddy
:g/^\s*$/d                  : delete all blank lines
:g!/^dd/d                   : delete lines not containing string
:v/^dd/d                    : delete lines not containing string
:g/fred/,/joe/d             : not line based (very powerfull)
:g/fred/,/joe/j             : Join Lines *N*
:g/-------/.-10,.d          : Delete string &amp; 10 previous lines
:g/{/ ,/}/- s/\n\+/\r/g     : Delete empty lines but only between {...}
:v/\S/d                     : Delete empty lines (both types)
:v/./,/./-j                 : compress empty lines
:g/^$/,/./-j                : compress empty lines
:g/&lt;input\|&lt;form/p          : ORing
:g/^/put_                   : double space file (pu = put)
:g/^/m0                     : Reverse file (m = move)
:g/^/m$                     : No effect! *N*
:'a,'bg/^/m'b               : Reverse a section a to b
:g/^/t.                     : duplicate every line
:g/fred/t$                  : copy(transfer) lines matching fred to EOF
:g/stage/t'a                : copy (transfer) lines matching stage to marker a (cannot use .) *C*
:g/^Chapter/t.|s/./-/g      : Automatically underline selecting headings *N*
:g/\(^I[^^I]*\)\{80}/d      : delete all lines containing at least 80 tabs
&quot; perform a substitute on every other line
:g/^/ if line('.')%2|s/^/zz / 
&quot; match all lines containing &quot;somestr&quot; between markers a &amp; b
&quot; copy after line containing &quot;otherstr&quot;
:'a,'bg/somestr/co/otherstr/ : co(py) or mo(ve)
&quot; as above but also do a substitution
:'a,'bg/str1/s/str1/&amp;&amp;&amp;/|mo/str2/
:%norm jdd                  : delete every other line
&quot; incrementing numbers (type &lt;c-a&gt; as 5 characters)
:.,$g/^\d/exe &quot;norm! \&lt;c-a&gt;&quot;: increment numbers
:'a,'bg/\d\+/norm! ^A       : increment numbers
&quot; storing glob results (note must use APPEND) you need to empty reg a first with qaq. 
&quot;save results to a register/paste buffer
:g/fred/y A                 : append all lines fred to register a
:g/fred/y A | :let @*=@a    : put into paste buffer
:let @a=''|g/Barratt/y A |:let @*=@a
&quot; filter lines to a file (file must already exist)
:'a,'bg/^Error/ . w &gt;&gt; errors.txt
&quot; duplicate every line in a file wrap a print '' around each duplicate
:g/./yank|put|-1s/'/&quot;/g|s/.*/Print '&amp;'/
&quot; replace string with contents of a file, -d deletes the &quot;mark&quot;
:g/^MARK$/r tmp.txt | -d
&quot; display prettily
:g/&lt;pattern&gt;/z#.5           : display with context
:g/&lt;pattern&gt;/z#.5|echo &quot;==========&quot;  : display beautifully
&quot; Combining g// with normal mode commands
:g/|/norm 2f|r*                      : replace 2nd | with a star
&quot;send output of previous global command to a new window
:nmap &lt;F3&gt;  :redir @a&lt;CR&gt;:g//&lt;CR&gt;:redir END&lt;CR&gt;:new&lt;CR&gt;:put! a&lt;CR&gt;&lt;CR&gt;
&quot;----------------------------------------
&quot; Global combined with substitute (power editing)
:'a,'bg/fred/s/joe/susan/gic :  can use memory to extend matching
:/fred/,/joe/s/fred/joe/gic :  non-line based (ultra)
:/biz/,/any/g/article/s/wheel/bucket/gic:  non-line based *N*
----------------------------------------
&quot; Find fred before beginning search for joe
:/fred/;/joe/-2,/sid/+3s/sally/alley/gIC
&quot;----------------------------------------
&quot; create a new file for each line of file eg 1.txt,2.txt,3,txt etc
:g/^/exe &quot;.w &quot;.line(&quot;.&quot;).&quot;.txt&quot;
&quot;----------------------------------------
&quot; chain an external command
:.g/^/ exe &quot;.!sed 's/N/X/'&quot; | s/I/Q/    *N*
&quot;----------------------------------------
&quot; Operate until string found *N*
d/fred/                                :delete until fred
y/fred/                                :yank until fred
c/fred/e                               :change until fred end
&quot;----------------------------------------
&quot; Summary of editing repeats *N*
.      last edit (magic dot)
:&amp;     last substitute
:%&amp;    last substitute every line
:%&amp;gic last substitute every line confirm
g%     normal mode repeat last substitute
g&amp;     last substitute on all lines
@@     last recording
@:     last command-mode command
:!!    last :! command
:~     last substitute
:help repeating
----------------------------------------
&quot; Summary of repeated searches
;      last f, t, F or T
,      last f, t, F or T in opposite direction
n      last / or ? search
N      last / or ? search in opposite direction
----------------------------------------
&quot; Absolutely essential
----------------------------------------
* # g* g#           : find word under cursor (&lt;cword&gt;) (forwards/backwards)
%                   : match brackets {}[]()
.                   : repeat last modification 
@:                  : repeat last : command (then @@)
matchit.vim         : % now matches tags &lt;tr&gt;&lt;td&gt;&lt;script&gt; &lt;?php etc
&lt;C-N&gt;&lt;C-P&gt;          : word completion in insert mode
&lt;C-X&gt;&lt;C-L&gt;          : Line complete SUPER USEFUL
/&lt;C-R&gt;&lt;C-W&gt;         : Pull &lt;cword&gt; onto search/command line
/&lt;C-R&gt;&lt;C-A&gt;         : Pull &lt;CWORD&gt; onto search/command line
:set ignorecase     : you nearly always want this
:set smartcase      : overrides ignorecase if uppercase used in search string (cool)
:syntax on          : colour syntax in Perl,HTML,PHP etc
:set syntax=perl    : force syntax (usually taken from file extension)
:h regexp&lt;C-D&gt;      : type control-D and get a list all help topics containing
                      regexp (plus use TAB to Step thru list)
----------------------------------------
&quot; MAKE IT EASY TO UPDATE/RELOAD _vimrc
:nmap ,s :source $VIM/_vimrc
:nmap ,v :e $VIM/_vimrc
:e $MYVIMRC         : edits your _vimrc whereever it might be  *N*
&quot; How to have a variant in your .vimrc for different PCs *N*
if $COMPUTERNAME == &quot;NEWPC&quot;
ab mypc vista
else
ab mypc dell25
endif
----------------------------------------
&quot; splitting windows
:vsplit other.php       # vertically split current file with other.php *N*
----------------------------------------
&quot;VISUAL MODE (easy to add other HTML Tags)
:vmap sb &quot;zdi&lt;b&gt;&lt;C-R&gt;z&lt;/b&gt;&lt;ESC&gt;  : wrap &lt;b&gt;&lt;/b&gt; around VISUALLY selected Text
:vmap st &quot;zdi&lt;?= &lt;C-R&gt;z ?&gt;&lt;ESC&gt;  : wrap &lt;?=   ?&gt; around VISUALLY selected Text
----------------------------------------
&quot;vim 7 tabs
vim -p fred.php joe.php             : open files in tabs
:tabe fred.php                      : open fred.php in a new tab
:tab ball                           : tab open files
&quot; vim 7 forcing use of tabs from .vimrc
:nnoremap gf &lt;C-W&gt;gf
:cab      e  tabe
:tab sball                           : retab all files in buffer (repair) *N*
----------------------------------------
&quot; Exploring
:e .                            : file explorer
:Exp(lore)                      : file explorer note capital Ex
:Sex(plore)                     : file explorer in split window
:browse e                       : windows style browser
:ls                             : list of buffers
:cd ..                          : move to parent directory
:args                           : list of files
:args *.php                     : open list of files (you need this!)
:lcd %:p:h                      : change to directory of current file
:autocmd BufEnter * lcd %:p:h   : change to directory of current file automatically (put in _vimrc)
----------------------------------------
&quot; Changing Case
guu                             : lowercase line
gUU                             : uppercase line
Vu                              : lowercase line
VU                              : uppercase line
g~~                             : flip case line
vEU                             : Upper Case Word
vE~                             : Flip Case Word
ggguG                           : lowercase entire file
&quot; Titlise Visually Selected Text (map for .vimrc)
vmap ,c :s/\&lt;\(.\)\(\k*\)\&gt;/\u\1\L\2/g&lt;CR&gt;
&quot; titlise a line
nmap ,t :s/.*/\L&amp;/&lt;bar&gt;:s/\&lt;./\u&amp;/g&lt;cr&gt;  *N*
&quot; Uppercase first letter of sentences
:%s/[.!?]\_s\+\a/\U&amp;\E/g
----------------------------------------
gf                              : open file name under cursor (SUPER)
:nnoremap gF :view &lt;cfile&gt;&lt;cr&gt;  : open file under cursor, create if necessary
ga                              : display hex,ascii value of char under cursor
ggVGg?                          : rot13 whole file
ggg?G                           : rot13 whole file (quicker for large file)
:8 | normal VGg?                : rot13 from line 8
:normal 10GVGg?                 : rot13 from line 8
&lt;C-A&gt;,&lt;C-X&gt;                     : increment,decrement number under cursor
                                  win32 users must remap CNTRL-A
&lt;C-R&gt;=5*5                       : insert 25 into text (mini-calculator)
----------------------------------------
&quot; Make all other tips superfluous
:h 42            : also http://www.google.com/search?q=42
:h holy-grail
:h!
----------------------------------------
&quot; disguise text (watch out) *N*
ggVGg?                          : rot13 whole file (toggles)
:set rl!                        : reverse lines right to left (toggles)
:g/^/m0                         : reverse lines top to bottom (toggles)
----------------------------------------
&quot; Markers &amp; moving about
'.               : jump to last modification line (SUPER)
`.               : jump to exact spot in last modification line
g;               : cycle thru recent changes (oldest first)
g,               : reverse direction 
:changes
:h changelist    : help for above
&lt;C-O&gt;            : retrace your movements in file (starting from most recent)
&lt;C-I&gt;            : retrace your movements in file (reverse direction)
:ju(mps)         : list of your movements
:help jump-motions
:history         : list of all your commands
:his c           : commandline history
:his s           : search history
q/               : Search history Window (puts you in full edit mode) (exit CTRL-C)
q:               : commandline history Window (puts you in full edit mode) (exit CTRL-C)
:&lt;C-F&gt;           : history Window (exit CTRL-C)
----------------------------------------
&quot; Abbreviations &amp; Maps
&quot; Following 4 maps enable text transfer between VIM sessions
:map   &lt;f7&gt;   :'a,'bw! c:/aaa/x       : save text to file x
:map   &lt;f8&gt;   :r c:/aaa/x             : retrieve text 
:map   &lt;f11&gt;  :.w! c:/aaa/xr&lt;CR&gt;      : store current line
:map   &lt;f12&gt;  :r c:/aaa/xr&lt;CR&gt;        : retrieve current line
:ab php          : list of abbreviations beginning php
:map ,           : list of maps beginning ,
&quot; allow use of F10 for mapping (win32)
set wak=no       : :h winaltkeys
&quot; For use in Maps
&lt;CR&gt;             : carriage Return for maps
&lt;ESC&gt;            : Escape
&lt;LEADER&gt;         : normally \
&lt;BAR&gt;            : | pipe
&lt;BACKSPACE&gt;      : backspace
&lt;SILENT&gt;         : No hanging shell window
#display RGB colour under the cursor eg #445588
:nmap &lt;leader&gt;c :hi Normal guibg=#&lt;c-r&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;cr&gt;&lt;cr&gt;
map &lt;f2&gt; /price only\\|versus/ :in a map need to backslash the \
# type table,,, to get &lt;table&gt;&lt;/table&gt;       ### Cool ###
imap ,,, &lt;esc&gt;bdwa&lt;&lt;esc&gt;pa&gt;&lt;cr&gt;&lt;/&lt;esc&gt;pa&gt;&lt;esc&gt;kA
----------------------------------------
&quot; Simple PHP debugging display all variables yanked into register a
iab phpdb exit(&quot;&lt;hr&gt;Debug &lt;C-R&gt;a  &quot;);
----------------------------------------
&quot; Using a register as a map (preload registers in .vimrc)
:let @m=&quot;:'a,'bs/&quot;
:let @s=&quot;:%!sort -u&quot;
----------------------------------------
&quot; Useful tricks
&quot;ayy@a           : execute &quot;Vim command&quot; in a text file
yy@&quot;             : same thing using unnamed register
u@.              : execute command JUST typed in
&quot;ddw             : store what you delete in register d *N*
&quot;ccaw            : store what you change in register c *N*
----------------------------------------
&quot; Get output from other commands (requires external programs)
:r!ls -R         : reads in output of ls
:put=glob('**')  : same as above                 *N*
:r !grep &quot;^ebay&quot; file.txt  : grepping in content   *N*
:20,25 !rot13    : rot13 lines 20 to 25   *N*
!!date           : same thing (but replaces/filters current line)
&quot; Sorting with external sort
:%!sort -u       : use an external program to filter content
:'a,'b!sort -u   : use an external program to filter content
!1} sort -u      : sorts paragraph (note normal mode!!)
:g/^$/;,/^$/-1!sort : Sort each block (note the crucial ;)
&quot; Sorting with internal sort
:sort /.*\%2v/   : sort all lines on second column *N*
----------------------------------------
&quot; Multiple Files Management (Essential)
:bn              : goto next buffer
:bp              : goto previous buffer
:wn              : save file and move to next (super)
:wp              : save file and move to previous
:bd              : remove file from buffer list (super)
:bun             : Buffer unload (remove window but not from list)
:badd file.c     : file from buffer list
:b3              : go to buffer 3 *C*
:b main          : go to buffer with main in name eg main.c (ultra)
:sav php.html    : Save current file as php.html and &quot;move&quot; to php.html
:sav! %&lt;.bak     : Save Current file to alternative extension (old way)
:sav! %:r.cfm    : Save Current file to alternative extension
:sav %:s/fred/joe/           : do a substitute on file name
:sav %:s/fred/joe/:r.bak2    : do a substitute on file name &amp; ext.
:!mv % %:r.bak   : rename current file (DOS use Rename or DEL)
:help filename-modifiers
:e!              : return to unmodified file
:w c:/aaa/%      : save file elsewhere
:e #             : edit alternative file (also cntrl-^)
:rew             : return to beginning of edited files list (:args)
:brew            : buffer rewind
:sp fred.txt     : open fred.txt into a split
:sball,:sb       : Split all buffers (super)
:scrollbind      : in each split window
:map   &lt;F5&gt; :ls&lt;CR&gt;:e # : Pressing F5 lists all buffer, just type number
:set hidden      : Allows to change buffer w/o saving current buffer
----------------------------------------
&quot; Quick jumping between splits
map &lt;C-J&gt; &lt;C-W&gt;j&lt;C-W&gt;_
map &lt;C-K&gt; &lt;C-W&gt;k&lt;C-W&gt;_
----------------------------------------
&quot; Recording (BEST TIP of ALL)
qq  # record to q
your complex series of commands
q   # end recording
@q to execute
@@ to Repeat
5@@ to Repeat 5 times
qQ@qq                             : Make an existing recording q recursive *N*
&quot; editing a register/recording
&quot;qp                               :display contents of register q (normal mode)
&lt;ctrl-R&gt;q                         :display contents of register q (insert mode)
&quot; you can now see recording contents, edit as required
&quot;qdd                              :put changed contacts back into q
@q                                :execute recording/register q
&quot; Operating a Recording on a Visual BLOCK
1) define recording/register
qq:s/ to/ from/g^Mq
2) Define Visual BLOCK
V}
3) hit : and the following appears
:'&lt;,'&gt;
4)Complete as follows
:'&lt;,'&gt;norm @q
----------------------------------------
&quot;combining a recording with a map (to end up in command mode)
:nnoremap ] @q:update&lt;bar&gt;bd
----------------------------------------
&quot; Visual is the newest and usually the most intuitive editing mode
&quot; Visual basics
v                               : enter visual mode
V                               : visual mode whole line
&lt;C-V&gt;                           : enter VISUAL BLOCK mode
gv                              : reselect last visual area (ultra)
o                               : navigate visual area
&quot;*y or &quot;+y                      : yank visual area into paste buffer  *C*
V%                              : visualise what you match
V}J                             : Join Visual block (great)
V}gJ                            : Join Visual block w/o adding spaces
`[v`]                           : Highlight last insert
:%s/\%Vold/new/g                : Do a substitute on last visual area *N*
----------------------------------------
&quot; Delete first 2 characters of 10 successive lines
0&lt;c-v&gt;10j2ld
----------------------------------------
&quot; how to copy a set of columns using VISUAL BLOCK
&quot; visual block (AKA columnwise selection) (NOT BY ordinary v command)
&lt;C-V&gt; then select &quot;column(s)&quot; with motion commands (win32 &lt;C-Q&gt;)
then c,d,y,r etc
----------------------------------------
&quot; how to overwrite a visual-block of text with another such block *C*
&quot; move with hjkl etc
Pick the first block: ctrl-v move y
Pick the second block: ctrl-v move P &lt;esc&gt;
----------------------------------------
&quot; text objects :h text-objects                                     *C*
daW                                   : delete contiguous non whitespace
di&lt;   yi&lt;  ci&lt;                        : Delete/Yank/Change HTML tag contents
da&lt;   ya&lt;  ca&lt;                        : Delete/Yank/Change whole HTML tag
dat   dit                             : Delete HTML tag pair
diB   daB                             : Empty a function {}
das                                   : delete a sentence
----------------------------------------
&quot; _vimrc essentials
:set incsearch : jumps to search word as you type (annoying but excellent)
:set wildignore=*.o,*.obj,*.bak,*.exe : tab complete now ignores these
:set shiftwidth=3                     : for shift/tabbing
:set vb t_vb=&quot;.                       : set silent (no beep)
:set browsedir=buffer                 : Maki GUI File Open use current directory
----------------------------------------
&quot; launching Win IE
:nmap ,f :update&lt;CR&gt;:silent !start c:\progra~1\intern~1\iexplore.exe file://%:p&lt;CR&gt;
:nmap ,i :update&lt;CR&gt;: !start c:\progra~1\intern~1\iexplore.exe &lt;cWORD&gt;&lt;CR&gt;
----------------------------------------
&quot; FTPing from VIM
cmap ,r  :Nread ftp://209.51.134.122/public_html/index.html
cmap ,w  :Nwrite ftp://209.51.134.122/public_html/index.html
gvim ftp://www.somedomain.com/index.html # uses netrw.vim
----------------------------------------
&quot; appending to registers (use CAPITAL)
&quot; yank 5 lines into &quot;a&quot; then add a further 5
&quot;a5yy
10j
&quot;A5yy
----------------------------------------
[I     : show lines matching word under cursor &lt;cword&gt; (super)
----------------------------------------
&quot; Conventional Shifting/Indenting
:'a,'b&gt;&gt;
&quot; visual shifting (builtin-repeat)
:vnoremap &lt; &lt;gv
:vnoremap &gt; &gt;gv
&quot; Block shifting (magic)
&gt;i{
&gt;a{
&quot; also
&gt;% and &lt;%
----------------------------------------
&quot; Redirection &amp; Paste register *
:redir @*                    : redirect commands to paste buffer
:redir END                   : end redirect
:redir &gt;&gt; out.txt            : redirect to a file
&quot; Working with Paste buffer
&quot;*yy                         : yank to paste
&quot;*p                          : insert from paste buffer
&quot; yank to paste buffer (ex mode)
:'a,'by*                     : Yank range into paste
:%y*                         : Yank whole buffer into paste
:.y*                         : Yank Current line to paster
&quot; filter non-printable characters from the paste buffer
&quot; useful when pasting from some gui application
:nmap &lt;leader&gt;p :let @* = substitute(@*,'[^[:print:]]','','g')&lt;cr&gt;&quot;*p
----------------------------------------
&quot; Re-Formatting text
gq}                          : Format a paragraph
gqap                         : Format a paragraph
ggVGgq                       : Reformat entire file
Vgq                          : current line
&quot; break lines at 70 chars, if possible after a ;
:s/.\{,69\};\s*\|.\{,69\}\s\+/&amp;\r/g
----------------------------------------
&quot; Operate command over multiple files
:argdo %s/foo/bar/e          : operate on all files in :args
:bufdo %s/foo/bar/e
:windo %s/foo/bar/e
:argdo exe '%!sort'|w!       : include an external command
:bufdo exe &quot;normal @q&quot; | w   : perform a recording on open files
:silent bufdo !zip proj.zip %:p   : zip all current files
----------------------------------------
&quot; Command line tricks
gvim -h                    : help
ls | gvim -                : edit a stream!!
cat xx | gvim - -c &quot;v/^\d\d\|^[3-9]/d &quot; : filter a stream
gvim -o file1 file2        : open into a split
&quot; execute one command after opening file
gvim.exe -c &quot;/main&quot; joe.c  : Open joe.c &amp; jump to &quot;main&quot;
&quot; execute multiple command on a single file
vim -c &quot;%s/ABC/DEF/ge | update&quot; file1.c
&quot; execute multiple command on a group of files
vim -c &quot;argdo %s/ABC/DEF/ge | update&quot; *.c
&quot; remove blocks of text from a series of files
vim -c &quot;argdo /begin/+1,/end/-1g/^/d | update&quot; *.c
&quot; Automate editing of a file (Ex commands in convert.vim)
vim -s &quot;convert.vim&quot; file.c
#load VIM without .vimrc and plugins (clean VIM)
gvim -u NONE -U NONE -N
&quot; Access paste buffer contents (put in a script/batch file)
gvim -c 'normal ggdG&quot;*p' c:/aaa/xp
&quot; print paste contents to default printer
gvim -c 's/^/\=@*/|hardcopy!|q!'
&quot; gvim's use of external grep (win32 or *nix)
:grep somestring *.php     : creates a list of all matching files
&quot; use :cn(ext) :cp(rev) to navigate list
:h grep
&quot; Using vimgrep with copen                              *N*
:vimgrep /keywords/ *.php
:copen
----------------------------------------
&quot; GVIM Difference Function (Brilliant)
gvim -d file1 file2        : vimdiff (compare differences)
dp                         : &quot;put&quot; difference under cursor to other file
do                         : &quot;get&quot; difference under cursor from other file
&quot; complex diff parts of same file *N*
:1,2yank a | 7,8yank b
:tabedit | put a | vnew | put b
:windo diffthis 
----------------------------------------
&quot; Vim traps
In regular expressions you must backslash + (match 1 or more)
In regular expressions you must backslash | (or)
In regular expressions you must backslash ( (group)
In regular expressions you must backslash { (count)
/fred\+/                   : matches fred/freddy but not free
/\(fred\)\{2,3}/           : note what you have to break
----------------------------------------
&quot; \v or very magic (usually) reduces backslashing
/codes\(\n\|\s\)*where  : normal regexp
/\vcodes(\n|\s)*where   : very magic
----------------------------------------
&quot; pulling objects onto command/search line (SUPER)
&lt;C-R&gt;&lt;C-W&gt; : pull word under the cursor into a command line or search
&lt;C-R&gt;&lt;C-A&gt; : pull WORD under the cursor into a command line or search
&lt;C-R&gt;-                  : pull small register (also insert mode)
&lt;C-R&gt;[0-9a-z]           : pull named registers (also insert mode)
&lt;C-R&gt;%                  : pull file name (also #) (also insert mode)
&lt;C-R&gt;=somevar           : pull contents of a variable (eg :let sray=&quot;ray[0-9]&quot;)
----------------------------------------
&quot; List your Registers
:reg             : display contents of all registers
:reg a           : display content of register a
:reg 12a         : display content of registers 1,2 &amp; a *N*
&quot;5p              : retrieve 5th &quot;ring&quot; 
&quot;1p....          : retrieve numeric registers one by one
:let @y='yy@&quot;'   : pre-loading registers (put in .vimrc)
qqq              : empty register &quot;q&quot;
qaq              : empty register &quot;a&quot;
:reg .-/%:*&quot;     : the seven special registers *N*
:reg 0           : what you last yanked, not affected by a delete *N*
&quot;_dd             : Delete to blackhole register &quot;_ , don't affect any register *N*
----------------------------------------
&quot; manipulating registers
:let @a=@_              : clear register a
:let @a=&quot;&quot;              : clear register a
:let @a=@&quot;              : Save unnamed register *N*
:let @*=@a              : copy register a to paste buffer
:let @*=@:              : copy last command to paste buffer
:let @*=@/              : copy last search to paste buffer
:let @*=@%              : copy current filename to paste buffer
----------------------------------------
&quot; help for help (USE TAB)
:h quickref             : VIM Quick Reference Sheet (ultra)
:h tips                 : Vim's own Tips Help
:h visual&lt;C-D&gt;&lt;tab&gt;     : obtain  list of all visual help topics
                        : Then use tab to step thru them
:h ctrl&lt;C-D&gt;            : list help of all control keys
:helpg uganda           : grep HELP Files use :cn, :cp to find next
:helpgrep edit.*director: grep help using regexp
:h :r                   : help for :ex command
:h CTRL-R               : normal mode
:h /\r                  : what's \r in a regexp (matches a &lt;CR&gt;)
:h \\zs                 : double up backslash to find \zs in help
:h i_CTRL-R             : help for say &lt;C-R&gt; in insert mode
:h c_CTRL-R             : help for say &lt;C-R&gt; in command mode
:h v_CTRL-V             : visual mode
:h tutor                : VIM Tutor
&lt;C-[&gt;, &lt;C-T&gt;            : Move back &amp; Forth in HELP History
gvim -h                 : VIM Command Line Help
:cabbrev h tab h        : open help in a tab *N*
----------------------------------------
&quot; where was an option set
:scriptnames            : list all plugins, _vimrcs loaded (super)
:verbose set history?   : reveals value of history and where set
:function               : list functions
:func SearchCompl       : List particular function
----------------------------------------
&quot; making your own VIM help
:helptags /vim/vim64/doc  : rebuild all *.txt help files in /doc
:help add-local-help
----------------------------------------
&quot; running file thru an external program (eg php)
map   &lt;f9&gt;   :w&lt;CR&gt;:!c:/php/php.exe %&lt;CR&gt;
map   &lt;f2&gt;   :w&lt;CR&gt;:!perl -c %&lt;CR&gt;
----------------------------------------
&quot; capturing output of current script in a separate buffer
:new | r!perl #                   : opens new buffer,read other buffer
:new! x.out | r!perl #            : same with named file
:new+read!ls
----------------------------------------
&quot; create a new buffer, paste a register &quot;q&quot; into it, then sort new buffer
:new +put q|%!sort
----------------------------------------
&quot; Inserting DOS Carriage Returns
:%s/$/\&lt;C-V&gt;&lt;C-M&gt;&amp;/g          :  that's what you type
:%s/$/\&lt;C-Q&gt;&lt;C-M&gt;&amp;/g          :  for Win32
:%s/$/\^M&amp;/g                  :  what you'll see where ^M is ONE character
----------------------------------------
&quot; automatically delete trailing Dos-returns,whitespace
autocmd BufRead * silent! %s/[\r \t]\+$//
autocmd BufEnter *.php :%s/[ \t\r]\+$//e
----------------------------------------
&quot; perform an action on a particular file or file type
autocmd VimEnter c:/intranet/note011.txt normal! ggVGg?
autocmd FileType *.pl exec('set fileformats=unix')
----------------------------------------
&quot; Retrieving last command line command for copy &amp; pasting into text
i&lt;c-r&gt;:
&quot; Retrieving last Search Command for copy &amp; pasting into text
i&lt;c-r&gt;/
----------------------------------------
&quot; more completions
&lt;C-X&gt;&lt;C-F&gt;                        :insert name of a file in current directory
----------------------------------------
&quot; Substituting a Visual area
&quot; select visual area as usual (:h visual) then type :s/Emacs/Vim/ etc
:'&lt;,'&gt;s/Emacs/Vim/g               : REMEMBER you dont type the '&lt;.'&gt;
gv                                : Re-select the previous visual area (ULTRA)
----------------------------------------
&quot; inserting line number into file
:g/^/exec &quot;s/^/&quot;.strpart(line(&quot;.&quot;).&quot;    &quot;, 0, 4)
:%s/^/\=strpart(line(&quot;.&quot;).&quot;     &quot;, 0, 5)
:%s/^/\=line('.'). ' '
----------------------------------------
#numbering lines VIM way
:set number                       : show line numbers
:map &lt;F12&gt; :set number!&lt;CR&gt;       : Show linenumbers flip-flop
:%s/^/\=strpart(line('.').&quot;        &quot;,0,&amp;ts)
#numbering lines (need Perl on PC) starting from arbitrary number
:'a,'b!perl -pne 'BEGIN{$a=223} substr($_,2,0)=$a++'
#Produce a list of numbers
#Type in number on line say 223 in an empty file
qqmnYP`n^Aq                       : in recording q repeat with @q
&quot; increment existing numbers to end of file (type &lt;c-a&gt; as 5 characters)
:.,$g/^\d/exe &quot;normal! \&lt;c-a&gt;&quot;
&quot; advanced incrementing
http://vim.sourceforge.net/tip_view.php?tip_id=150
----------------------------------------
&quot; advanced incrementing (really useful)
&quot; put following in _vimrc
let g:I=0
function! INC(increment)
let g:I =g:I + a:increment
return g:I
endfunction
&quot; eg create list starting from 223 incrementing by 5 between markers a,b
:let I=223
:'a,'bs/^/\=INC(5)/
&quot; create a map for INC
cab viminc :let I=223 \| 'a,'bs/$/\=INC(5)/
----------------------------------------
&quot; generate a list of numbers  23-64
o23&lt;ESC&gt;qqYp&lt;C-A&gt;q40@q
----------------------------------------
&quot; editing/moving within current insert (Really useful)
&lt;C-U&gt;                             : delete all entered
&lt;C-W&gt;                             : delete last word
&lt;HOME&gt;&lt;END&gt;                       : beginning/end of line
&lt;C-LEFTARROW&gt;&lt;C-RIGHTARROW&gt;       : jump one word backwards/forwards
&lt;C-X&gt;&lt;C-E&gt;,&lt;C-X&gt;&lt;C-Y&gt;             : scroll while staying put in insert
----------------------------------------
#encryption (use with care: DON'T FORGET your KEY)
:X                                : you will be prompted for a key
:h :X
----------------------------------------
&quot; modeline (make a file readonly etc) must be in first/last 5 lines
// vim:noai:ts=2:sw=4:readonly:
&quot; vim:ft=html:                    : says use HTML Syntax highlighting
:h modeline
----------------------------------------
&quot; Creating your own GUI Toolbar entry
amenu  Modeline.Insert\ a\ VIM\ modeline &lt;Esc&gt;&lt;Esc&gt;ggOvim:ff=unix ts=4 ss=4&lt;CR&gt;vim60:fdm=marker&lt;esc&gt;gg
----------------------------------------
&quot; A function to save word under cursor to a file
function! SaveWord()
   normal yiw
   exe ':!echo '.@0.' &gt;&gt; word.txt'
endfunction
map ,p :call SaveWord()
----------------------------------------
&quot; function to delete duplicate lines
function! Del()
 if getline(&quot;.&quot;) == getline(line(&quot;.&quot;) - 1)
   norm dd
 endif
endfunction

:g/^/ call Del()
----------------------------------------
&quot; Digraphs (non alpha-numerics)
:digraphs                         : display table
:h dig                            : help
i&lt;C-K&gt;e'                          : enters é
i&lt;C-V&gt;233                         : enters é (Unix)
i&lt;C-Q&gt;233                         : enters é (Win32)
ga                                : View hex value of any character
#Deleting non-ascii characters (some invisible)
:%s/[\x00-\x1f\x80-\xff]/ /g      : type this as you see it
:%s/[&lt;C-V&gt;128-&lt;C-V&gt;255]//gi       : where you have to type the Control-V
:%s/[€-ÿ]//gi                     : Should see a black square &amp; a dotted y
:%s/[&lt;C-V&gt;128-&lt;C-V&gt;255&lt;C-V&gt;01-&lt;C-V&gt;31]//gi : All pesky non-asciis
:exec &quot;norm /[\x00-\x1f\x80-\xff]/&quot;        : same thing
#Pull a non-ascii character onto search bar
yl/&lt;C-R&gt;&quot;                         :
/[^a-zA-Z0-9_[:space:][:punct:]]  : search for all non-ascii
----------------------------------------
&quot; All file completions grouped (for example main_c.c)
:e main_&lt;tab&gt;                     : tab completes
gf                                : open file under cursor  (normal)
main_&lt;C-X&gt;&lt;C-F&gt;                   : include NAME of file in text (insert mode)
----------------------------------------
&quot; Complex Vim
&quot; swap two words
:%s/\&lt;\(on\|off\)\&gt;/\=strpart(&quot;offon&quot;, 3 * (&quot;off&quot; == submatch(0)), 3)/g
&quot; swap two words
:vnoremap &lt;C-X&gt; &lt;Esc&gt;`.``gvP``P
&quot; Swap word with next word
nmap &lt;silent&gt; gw    &quot;_yiw:s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/&lt;cr&gt;&lt;c-o&gt;&lt;c-l&gt; *N*
----------------------------------------
&quot; Convert Text File to HTML
:runtime! syntax/2html.vim        : convert txt to html
:h 2html
----------------------------------------
&quot; VIM has internal grep
:grep some_keyword *.c            : get list of all c-files containing keyword
:cn                               : go to next occurrence
----------------------------------------
&quot; Force Syntax coloring for a file that has no extension .pl
:set syntax=perl
&quot; Remove syntax coloring (useful for all sorts of reasons)
:set syntax off
&quot; change coloring scheme (any file in ~vim/vim??/colors)
:colorscheme blue
&quot; Force HTML Syntax highlighting by using a modeline
# vim:ft=html:
&quot; Force syntax automatically (for a file with non-standard extension)
au BufRead,BufNewFile */Content.IE?/* setfiletype html
----------------------------------------
:set noma (non modifiable)        : Prevents modifications
:set ro (Read Only)               : Protect a file from unintentional writes
----------------------------------------
&quot; Sessions (Open a set of files)
gvim file1.c file2.c lib/lib.h lib/lib2.h : load files for &quot;session&quot;
:mksession                        : Make a Session file (default Session.vim)
:q
gvim -S Session.vim               : Reload all files
----------------------------------------
#tags (jumping to subroutines/functions)
taglist.vim                       : popular plugin
:Tlist                            : display Tags (list of functions)
&lt;C-]&gt;                             : jump to function under cursor
----------------------------------------
&quot; columnise a csv file for display only as may crop wide columns
:let width = 20
:let fill=' ' | while strlen(fill) &lt; width | let fill=fill.fill | endwhile
:%s/\([^;]*\);\=/\=strpart(submatch(1).fill, 0, width)/ge
:%s/\s\+$//ge
&quot; Highlight a particular csv column (put in .vimrc)
function! CSVH(x)
    execute 'match Keyword /^\([^,]*,\)\{'.a:x.'}\zs[^,]*/'
    execute 'normal ^'.a:x.'f,'
endfunction
command! -nargs=1 Csv :call CSVH(&lt;args&gt;)
&quot; call with
:Csv 5                             : highlight fifth column
----------------------------------------
&quot; folding : hide sections to allow easier comparisons
zf}                               : fold paragraph using motion
v}zf                              : fold paragraph using visual
zf'a                              : fold to mark
zo                                : open fold
zc                                : re-close fold
:help folding
----------------------------------------
&quot; displaying &quot;non-asciis&quot;
:set list
:h listchars
----------------------------------------
&quot; How to paste &quot;normal commands&quot; w/o entering insert mode
:norm qqy$jq
----------------------------------------
&quot; manipulating file names
:h filename-modifiers             : help
:w %                              : write to current file name
:w %:r.cfm                        : change file extention to .cfm
:!echo %:p                        : full path &amp; file name
:!echo %:p:h                      : full path only
:!echo %:t                        : filename only
:reg %                            : display filename
&lt;C-R&gt;%                            : insert filename (insert mode)
&quot;%p                               : insert filename (normal mode)
/&lt;C-R&gt;%                           : Search for file name in text
----------------------------------------
&quot; delete without destroying default buffer contents
&quot;_d                               : what you've ALWAYS wanted
&quot;_dw                              : eg delete word (use blackhole)
----------------------------------------
&quot; pull full path name into paste buffer for attachment to email etc
nnoremap &lt;F2&gt; :let @*=expand(&quot;%:p&quot;)&lt;cr&gt; :unix
nnoremap &lt;F2&gt; :let @*=substitute(expand(&quot;%:p&quot;), &quot;/&quot;, &quot;\\&quot;, &quot;g&quot;)&lt;cr&gt; :win32
----------------------------------------
&quot; Simple Shell script to rename files w/o leaving vim
$ vim
:r! ls *.c
:%s/\(.*\).c/mv &amp; \1.bla
:w !sh
:q!
----------------------------------------
&quot; count words in a text file
g&lt;C-G&gt;
----------------------------------------
&quot; example of setting your own highlighting
:syn match DoubleSpace &quot;  &quot;
:hi def DoubleSpace guibg=#e0e0e0
----------------------------------------
&quot; reproduce previous line word by word
imap ]  @@@&lt;ESC&gt;hhkyWjl?@@@&lt;CR&gt;P/@@@&lt;CR&gt;3s
nmap ] i@@@&lt;ESC&gt;hhkyWjl?@@@&lt;CR&gt;P/@@@&lt;CR&gt;3s
&quot; Programming keys depending on file type
:autocmd bufenter *.tex map &lt;F1&gt; :!latex %&lt;CR&gt;
:autocmd bufenter *.tex map &lt;F2&gt; :!xdvi -hush %&lt;.dvi&amp;&lt;CR&gt;
----------------------------------------
&quot; reading Ms-Word documents, requires antiword
:autocmd BufReadPre *.doc set ro
:autocmd BufReadPre *.doc set hlsearch!
:autocmd BufReadPost *.doc %!antiword &quot;%&quot;
----------------------------------------
&quot; a folding method
vim: filetype=help foldmethod=marker foldmarker=&lt;&lt;&lt;,&gt;&gt;&gt;
A really big section closed with a tag &lt;&lt;&lt; 
--- remember folds can be nested --- 
Closing tag &gt;&gt;&gt; 
----------------------------------------
&quot; Return to last edit position (You want this!) *N*
autocmd BufReadPost *
     \ if line(&quot;'\&quot;&quot;) &gt; 0 &amp;&amp; line(&quot;'\&quot;&quot;) &lt;= line(&quot;$&quot;) |
     \   exe &quot;normal! g`\&quot;&quot; |
     \ endif
----------------------------------------
&quot; store text that is to changed,deleted in register a
&quot;act&lt;                                 :  Change Till &lt; *N*
----------------------------------------
&quot; Just Another Vim Hacker JAVH
vim -c &quot;:%s%s*%Cyrnfr)fcbafbe[Oenz(Zbbyranne%|:%s)[[()])-)Ig|norm Vg?&quot;
----------------------------------------
__END__
----------------------------------------
&quot;Read Vimtips into a new vim buffer (needs w3m.sourceforge.net)
:tabe | :r ! w3m -dump http://zzapper.co.uk/vimtips.html    *N*
----------------------------------------

</pre>

<!-- Page published by Emacs Wiki ends here -->
    <div class="navfoot">
      <hr />
      <table width="100%" border="0" summary="Footer navigation">
        <col width="33%"/><col width="34%"/><col width="33%"/>
        <tr>
          <td align="left">Update : 2016-05-23
          </td>
          <td align="center">
           <span class="foothome">
              <a href="WelcomePage.html">Home</a> / <a href="WikiIndex.html">Index</a>
            </span>
          </td>
          <td align="right">
           cyberpsyche[AT]gmail.com
          </td>
        </tr>
      </table>
   <center>
     Based on
      <a href="http://www.debian.org"><img style="border: 0em none;" src="images/debianLogo.png" alt="Debian Logo" /></a>    
   <a href="http://www.debian.org"><img style="border: 0em none;" src="images/debian.png" alt="Debian Text Logo" /></a>   
       GNU/Linux&nbsp;and&nbsp;<a href="http://www.apple.com"><img style="border: 0em none;" src="images/MacLogo.jpg" alt="Mac Logo" /></a>OS X|&nbsp;Powered by    
      <a href="http://www.gnu.org/software/emacs"><img style="border: 0em none;" src="images/emacs.gif" alt="Emacs Logo" /></a>&nbsp;|   
      Best view with    
   <a href="http://www.getfirefox.com/"><img style="border: 0em none;" src="images/getFirefox.gif" alt="Firefox Logo" /></a> 
  </center>  
  </div>
  </body>
</html>